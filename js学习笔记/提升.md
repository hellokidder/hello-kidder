# 提升

作用域同其中的变量声明出现的位置有某种微妙的联系

```
a = 2;
var a;
console.log(a);// 2
```


```
console.log(a); //undefined
var a = 3;
```
**包括变量和函数在内的所有声明都会在任何代码被执行之前首先被处理**

> 只有声明本身被提升，而赋值或其他逻辑运算则被留在原地

> 每个作用域都会进行提升操作

```
foo();
function foo() {
    console.log(a); //undefined
    var a = 2;
} 
```
实际被理解的
```
function foo() {
    var a;
    console.log(a); //undefined
    a = 2;
} 
foo();
```
---
```
foo(); //TypeError
var foo = function bar() {
  ...  
};
```
```
var foo;
foo();
```
foo被声明但没有赋值（**如果他是一个函数声明而不是函数表达式，就会被赋值**），foo（）对undefined进行函数调用导致非法操作因此抛出TyprError异常。

**具名的函数表达式在，名称标识符在复制之前也无法在所在的作用域中使用**
```
foo(); //TypeError
bar(); //ReferenceError
var foo = function bar() {
  ...  
};
```
被理解成：
```
var foo;
foo(); //TypeError
bar(); //ReferenceError
foo = function {
    var bar = ...self...
    ...  
};
```

---
### 函数优先
函数声明和变量声明都会被提升，但是函数会首先被提升，然后才是变量。
```
foo();
var foo;
function foo() {
    console.log(1);
}
foo = function() {
    console.log(2);
}
//会输出1而不是2;
```
引擎的理解
```
function foo() {
    console.log(1);
}
foo();
foo = function() {
    console.log(2);
}
```
尽管foo在function foo()之前被声明，但是它是重复声明（因此被忽略了）

后面的函数声明可以覆盖前面的
```
foo(); // 3
function foo() {
    console.log(1);
}
var foo = function() {
    console.log(2);
}
function foo() {
    console.log(3);
}
```
函数声明会被提升到所在作用域的顶部，而不会受条件判断所控制
```
foo(); //"b"
var a = true;
if (a) {
    function foo() {console.log("a")}
}
else {
    function foo() {console.log("b")}
}
```
