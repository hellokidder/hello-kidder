### JavaScript是一种专为网页交互而设计的脚本语言
- **ECMAScript** 提供核心语言功能
- **文档对象模型（DOM）** 提供操作和访问网页内容的方法和接口
- **浏览器对象模型（BOM）** 提供与浏览器交互的方法和接口

# 作用域
尽管通常JavaScript被归类为‘动态’或‘解释执行’语言，但事实上JavaScript是一门**编译语言**
###### 普通编译过程
* 分词/词法分析（Tokening/Lexing）
    
    将由字符组成的字符串分解成有意义的代码块

* 解析/语法分析（Parsing）
    
    将词法单元流（数组）转换成一个有元素逐级嵌套所组成的代表了程序语法结构的树“抽象语法树”（AST）

* 代码生成

    将AST转换成为可执行代码的过程为代码生成（将AST转换为一组机器指令）
##### **JavaScript引擎更加复杂**
首先，JavaScript的编译过程不是发生在构建之前，所以JavaScript引擎不会有大量的时间进行优化，大部分情况下编译发生在代码执行前几微秒（甚至更短），在作用域背后JavaScript引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能。

---
- **引擎** 从头到尾负责整个JavaScript程序的编译及执行过程
- **编译器** 负责语法分析及代码生成
- **作用域** 负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限
---

> var a = 2;

编译器首先将这段程序分解成词法单元，然后将词法单元解析成一个树结构。

代码生成：

1. 遇到 var a,编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器忽略该声明，继续进行编译；否则它会要求作用域在当前作用域集合中声明一个新的变量，命名为a。

2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理a=2这个赋值操作。引擎运行时先询问作用域是否存在变量a，如果是就会使用这个变量，如果否继续查找该变量。
 
如果引擎找到了变量a，把2赋值给它，否则抛出异常

---

引擎查询a变量时进行的查询时执行的是**LHS查询**

**LHS查询**和**RHS查询**

L和R代表左侧和右侧

一个赋值操作的左侧和右侧（*并不一定是=的左侧和右侧，赋值操作还有其他几种形式*）

```
function foo(a) {
    console.log(a); // 2
}
foo(2);
```
最后一行foo(..)函数的调用需要对foo进行RHS引用

在2被当做参数传递给foo(..)函数时，2被分配给参数a，为了给参数a（隐式地）分配值，需要进行一次LHS查询。

对a进行RHS应用并将得到的值传给console.log(..)。console.log本身也需要一个引用才能执行，因此会对console对象进行RHS查询，并且检查得到的值中是否有一个叫做log的方法。

最后，概念上可以理解为在LHS和RHS之间通过对值2进行交互来将其传递进log（..）（通过变量a的RHS查询）。假设在log（..）函数的原生实现中它可以接受参数，在将2赋值给其中一个（也许叫arg1）参数之前
，这个参数需要进行LHS引用查询

---

### 作用域嵌套

当一个块或函数嵌套在另一个块或函数中时，就发生的作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域*也就是全局作用域*为止

---

### 异常

如果RHS查询在所有嵌套作用域中都找不到所需的变量，引擎就会抛出ReferenceError异常。

在宽松/懒惰模式下，当引擎执行LHS查询时，如果在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返回给引擎（非严格模式），严格模式下也会抛出与RHS查询类似的ReferenceError异常。

如果RHS查询找到了一个变量，但你尝试对这个变量进行不合理操作，那么引擎会抛出TypeError异常。

ReferenceError异常同作用域判别失败相关，TypeError异常代表作用域判别成功了，但是对结果的操作是不合理的

---

# 词法作用域

词法作用域就是定义在词法阶段的作用域。

换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样）

作用域气泡由其对应的作用域块代码写在哪里决定，它们是逐级包含的

气泡是严格包含的没有任何函数的气泡可以同时出现在两个外部作用域的气泡中，就如同没有任何函数可以部分地同时出现在两个父级函数中一样

**作用域查找会在找到第一个匹配的标识符时停止**

多层的嵌套作用域中可以定义同名的标识符，这叫做‘遮蔽效应’（内部的标识符‘遮蔽’了外部的标识符）

==全局变量会自动成为全局对象的属性，因此可以不直接通过全局对象的词法名称，而是间接地通过全局对象属性的引用来对其进行访问，通过这种技术可以访问那些被遮蔽的全局变量，但非全局变量被遮蔽，无论如何都访问不到==

**无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定**

词法作用域只会查找一级标识符，比如a,b,c。但如果代码中引用了foo.bar.baz,词法作用域只会查找的foo标识符，找到变量后，对象属性访问规则会分别接管bar和baz属性的访问

---
### 欺骗词法
**欺骗词法作用域会导致性能下降**

**eval**

JavaScript中的eval(..)函数可以接受一个字符串为参数，并将其中的内容视为好像书写时就存在于程序中这个位置的代码。

通过代码欺骗和假装书写时（词法期）代码就在那实现修改词法作用域的


```
function foo(str, a) {
    eval(str); // 欺骗
    console.log(a, b);
}
var b = 2;
foo("var b = 3;",1) // 1,3
```
==eval(..)通常被用来执行动态创建的代码==

默认情况下，如果eval(..)中所执行的代码包含有一个或多个声明（无论变量还是函数），就会对eval(..)词法作用域进行修改

**严格模式下 eval（..）在运行时尤其自己的词法作用域，所以其中的声明无法修改所在的作用域**

> JavaScript中还有其他一些功能效果和eval(..)很相似。setTimeout（..）和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码，==这些功能已经过时且不被提倡，不要使用它们==

> new Function(..)函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数（前面的参数是这个新生成的函数的形参）==这种构建函数的语法比eval(..)略安全一些，但也尽量不要使用==

==在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失==

**with**

with通常被当做重复引用同一个对象中的多个属性的快捷方式


```
var obj = {
    a: 1,
    b: 2,
    c: 3
};
// 单调重复 “obj”
obj.a = 2;
obj.b = 3;
obj.c = 4;
//快捷方式
with(obj){
    a = 3;
    b = 4;
    c = 5;
}
```
但是有些奇怪的事情会发生


```
function foo(obj) {
    with(obj) {
        a = 2;
    }
}
var o1 = {
    a: 3
};
var o2 = {
    b: 3
};

foo(o1);
console.log(o1.a);// 2

foo(o2);
console.log(o2.a);// undefined
console.log(a);// 2------????a被泄露到全局作用域上了
```

**with(..){}内部实际上执行的是一个LHS引用**

o2中没有a属性，所以o2.a保持undefined

==with可以将一个没有或者有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符==

> 尽管with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中

==eval(..)函数如果接受了含有一个或者多个声明的代码，就会修改其所处的词法作用域，而with声明实际上是根据你传递给它的对象凭空创建了一个**全新的词法作用域**==

**eval(..)和with会被严格模式影响**

> eval（..）和with可能会使JavaScript引擎的优化变得毫无意义，如果没有这些优化，代码会运行的更慢
