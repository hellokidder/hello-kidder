# 函数作用域

**属于这个函数的全部变量都可以在整个函数的范围内使用及复用**

可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来隐藏它们

> 最小授权/最小暴露原则：应该最小限度地暴露必要内容，而将其他部分隐藏起来。
因为他们可能被有意或者无意地以非预期的方式使用

‘隐藏’作用域中的变量所带来的另一个好处，就是可以避免同名标识符之间的冲突。冲突会导致变量的值被意外覆盖

```
function foo() {
    function bar(a){
        i = 3; // 修改了for循环中的i
        console.log(a+i);
    }
    for (var i=0;i<10;i++) {
        bar(i * 2); //无限循环
    }
}
foo();
```
变量冲突的一个典型例子存在于全局作用域中，当程序加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易发生冲突

**这些库通常会在全局作用域中声明一个名字足够独特的变量，这个变量通常是一个对象，这个对象被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中**

隐藏变量有两个问题

- 必须声明一个具名函数foo（），而函数foo()本身就‘污染’了所造的定义域
- 必须显示的通过函数名调用这个函数才能运行其中的代码

解决方案

```
var a = 2;
(function foo() { //<--这一行
    var a = 3;
    console.log(a); // 3
})(); //<--以及这一行
console.log(a); // 2
```
**包装函数的声明以（function..开始。函数会被当做函数表达式而不是标准的函数声明来处理**

> 区分函数声明和表达式最简单的办法是看function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如果function是声明中的第一个词，那么就是函数声明，否则就是一个函数表达式

函数声明和函数表达式之间最主要的区别是它们的名称标识符将会绑定到何处

第一个代码片段中foo被绑定到所在的作用域中，可以直接通过foo（）来调用它

第二个片段中foo被绑定在函数表达式自身的函数中而不是所在的作用域中

---
匿名函数表达式

```
setTimeout(function() {
    console.log("I waited 1 second!");
},1000);
```
这叫匿名函数表达式，因为function（）没有名称标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。

匿名函数表达式书写起来简单便捷，但是也有缺点：

1.  命名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
2.  如果没有函数名，当函数需要引用自身时只能使用已经过期的arguments.callee引用，比如在递归中。另一个函数需要引用自身的例子，是在事件触发后事件监听器需要解绑自身。
3.  匿名函数省略了对于代码可读性/可理解性很重要的函数名。一个描述性的名称可以让代码不言自明。

**内行函数表达式**  非常强大且有用——匿名和具名之间的区别并不会对这点有任何人影响。给函数表达式指定一个函数名可以有效地解决以上的问题。始终给函数表达式命名是一个最佳实践

```
setTimeout(function timeheader(){ // <--命名
    console.log("i waited 1 second!");
},1000);
```

---
立即执行函数表达式

> IIFE：代表立即执行函数表达式

```
var a = 2;
(function foo() {
    var a = 3;
    console.log(a); // 3
})(); //
console.log(a); // 2
```
**第一个（）将函数变成表达式，第二个（）执行这个函数（立即执行）**

函数名对IIFE不是必需的（推荐具名函数IIFE）

另一种写法（function（）{...}()）

两种形式的功能是一致的。

IIFE进阶用法：
1.
```
var a = 2;
(function IIFE(global){
    var a = 3;
    console.log(a); //3
    console.log(global.a); //2
})(window);
console.log(a); //2
```
将window对象的引用传递进去，将参数命名为global,更加清晰。

对改进代码风格非常有帮助

2. 解决undefined标识符的默认值被错误覆盖导致的异常
```
undefined = true;// 绝对不要这样做
(function IIFE(undefined){
    var a;
    if (a === undefined) {
        console.log("undefined is safe here!");
    }
})();
```
3.倒置代码运行顺序，将需要运行的函数放到第二位，在IIFE执行之后当做参数传进去。

```
var a = 2;
(function IIFE(def){
   def(window);
})(function IIFE(global){
    var a = 3;
    console.log(a); //3
    console.log(global.a); //2
});
```
---
### 块作用域

```
for (var i= 0;i<10;i++) {
    console.log(i); //i会被绑定在外部作用域（函数或者全局）
}
```
**with**

用with从对象中创建出的作用域仅在with声明中而非外部作用域中有效

**try/catch**

try/catch的catch分句会创建一个块作用域，其中声明的变量仅在catch内部有效


```
try {
    undefined(); // 执行一个非法操作来强行制造一个异常
}
catch （err） {
    console.log(err); //能够正常运行！
}
console.log(err); //ReferenceError:err not found
```
> 当同一个作用域中有两个或者多个catch分句用同样的标识符名称声明错误变量时，很多静态检查工具会报错，但实际上并不是重复定义

---
**let**

let可以将变量绑定到所在的任意作用域中（通常是{..}内部）

let为其声明的变量隐式的劫持了所在的块作用域


```
var foo = ture;
if (foo) {
    let bar = foo * 2;
    bar = something(bar);
    console.log(bar);
}
console.log(bar);// ReferenceError
```

用let将变量附加在已经存在的块作用域上的行为是隐式的。

```
var foo = ture;
if (foo) {
    { //<--显示的块
        let bar = foo * 2;
        bar = something(bar);
        console.log(bar);
    }
}
console.log(bar);// ReferenceError
```
**只要声明是有效的，在声明中的任意位置都可以使用{..}来为let创建一个用于绑定的的块**

> 使用let进行声明不会在块作用域中进行提升

```
{
    console.log(bar); //ReferenceError!
    let bar = 2;
}
```
---
垃圾收集

```
function precess(date) {
    // do something
}
var someReallyBigDate = {..};
precess(someReallyBigDate);
var btn = document.getElementById("my_button");
btn.addEventListener("click",function click(evt) {
    console.log("button clicked");
},/* capturingPhase=*/false);
```
click函数的点击回调并不需要someReallyBigDate变量。理论上这意味着当precess(..)执行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于click函数形成了一个覆盖整个作用域的闭包，JavaScript引擎极有可能依然保存着这个结构

块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存someReallyBigDate了：

```
function precess(date) {
    // do something
}
{   这个块中定义的内容完事可以销毁
    let someReallyBigDate = {..};
    precess(someReallyBigDate);
}
var btn = document.getElementById("my_button");
btn.addEventListener("click",function click(evt) {
    console.log("button clicked");
},/* capturingPhase=*/false);
```
**为变量显示声明块作用域，并对变量进行本地绑定是非常有用的工具**

---
let循环

```
for (let i=0;i<10;i++) {
    console.log(i);
}
console.log(i);// ReferenceError

```
let 将i重新绑定到了循环的每个迭代中

```
{
    let j;
    for (j=0;j<10;j++) {
        let i = j;// 每个迭代都重新绑定！
        console.log(i);
    }
}

```
由于let声明附属于一个新的作用域而不是当前的函数作用域（也不属于全局作用域），
当代码中存在对于函数作用域中var声明的隐式依赖时，就会有很多隐藏的陷阱，如果用let来替代var则需要在代码重构过程中付出额外的精力。

```
var foo = true,baz = 10;
if(foo) {
    var bar = 3;
    if(baz>bar) {
        console.log(baz);
    }
    //...
}
```
简单的重构
```
var foo = true,baz = 10;
if(foo) {
    var bar = 3;
    //...
}
if(baz>bar) {
    console.log(baz);
}
```
但是如果使用块级作用域时注意


```
var foo = true,baz = 10;
if(foo) {
    let bar = 3; //<--注意bar
    if(baz>bar) {
        console.log(baz);
    }
    //...
}
```
---
**const**

const 同样可以用来创建块级作用域变量，但是其值是固定不变的常量，**之后任何试图修改值的操作都会引起错误**


```
var foo = true;
if(foo) {
    var a = 2;
    const b = 3; //包含在if中的块作用域常量
    a = 3; //正常！
    b = 4; //错误！
}
console.log(a);//3
console.log(b);//ReferencrError

```
