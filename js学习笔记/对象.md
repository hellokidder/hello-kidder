# 对象

### 语法

对象可以通过两种方法定义：声明（文字）形式和构造形式

声明：
```javascript
var myObj = {
    key:value
    //...
};
```
构造：
```javascript
var myObj = new Object();
myObj.key = value;
```
构造形式和文字形式生成的对象是一样的，唯一的区别是文字形式你可以一次添加多个键值对，而构造形式中必须逐个添加属性

---

### 类型

对象是JavaScript的基础，在JavaScript中一共有六种主要类型（术语是“语言类型”）：

- string
- number
- boolean
- null
- undefined
- object

> 注意：简单基本类型（string,number,boolean,null,undefined）本身并不是对象。null有时会被当做一种对象类型，但是这其实只是语言本身的BUG，即对null执行typyof null时会返回字符串“object”。实际上null本身是基本类型。

有一种常见的错误说法“JavaScript中万物皆对象”，这显然是错误的。

实际上，JavaScript中有许多特殊的对象子类型，我们可以称之为复杂基本类型

函数就是对象的一个子类型，数组也是对象的一种类型

#### 内置对象

JavaScript中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基本类型一样，不过实际上他们关系更复杂

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error
 
这些内置对象从表现形式上来说很像其他语言中的类型（type）或者类（class）比如Java中的String类。
但是在JavaScript中，它们实际上只是一些内置函数，这些内置函数可以当做构造函数（由new产生的函数调用）来使用，从而可以构造一个对应子类型的新对象
```javascript
var strPrimitive = "I am a string";
console.log(typeof strPrimitive);//string
console.log(strPrimitive instanceof String);//false

var strObject = new String("I am a string");
console.log(typeof strObject);//object
console.log(strObject instanceof String);//true

//检查 sub-type 对象
console.log(Object.prototype.toString.call(strObject));//[object String]

```

strObject是由String构造函数创建一个对象，原始值“I am a string”并不是一个对象，它只是一个字面量，并且是一个不可变得值。如果要在这个字面量上执行一些操作，比如获取长度，访问其中某一个字符等，那就需要将其转换为String对象。有必要时语言会自动把字符串字面量转换成一个String对象

```javascript
var strPrimitive = "I am a string";
console.log(strPrimitive.length); // 13
console.log(strPrimitive.charAt(3)); //m
```
使用以上两种方法可以直接在字符串字面量上访问属性和方法，因为引擎自动把字面量转换成String对象，所以可以访问属性和方法
同样的事也会发生在数值字面量上，如果使用42.123toFixed(2)的方法，引擎会把42转换成new number(42).对于布尔字面量来说也是如此

> null和undefined没有对应的构造形式，它们只有文字形式，相反，Date只有构造，没有文字形式。

> 对于Object，Array，Function，和RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量

> Error对象很少在代码中显式创建，一般是在抛出异常时被自动创建

#### 内容

```javascript
var myObject = {
  a:2
};
console.log(myObject.a);//2
console.log(myObject["a"]);//2
```
.a语法通常被称为“属性访问”；

["a"]语法通常被称为“建访问”；

实际上它们访问的是同一个位置，所以这两个术语是可以相互转换的

这两种愈发的主要区别就是：.操作符要求属性名满足标识符的命名规范，而[".."]语法可以接受任意UFT-8/Unicode字符串作为属性名。比如要引用“Super-Fun!”就只能使用["Super-Fun"]

> 属性名永远是字符串，即使使用string（字面量）以外的其它属性名，那么他首先会被转换成字符串

###### 可计算属姓名

ES6增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当属性名：
```javascript
var prefix = "kidder";

var myObject = {
  [prefix+"cool"]:"hello!",
  [prefix+"bar"]:"kidder"
};

console.log(myObject.kiddercool);//hello!
console.log(myObject.kidderbar);//kidder
```
######  数组

数组也支持[]访问形式，数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数
```javascript
var myArray = ["foo",42,"bar"];
myArray.length; //3
myArray[0]; //"foo"
myArray[2]; //"bar" 
```
数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性
```javascript
var myArray = ["foo",42,"bar"];
myArray.baz = "baz";
myArray.length; //3
console.log(myArray.baz);
```
> 虽然添加了命名属性，但数组的length值并没有发生变化

注意:如果你试图向数组添加一个属性，但属性名“看起来”像个数字，那么它就会变成一个数值的下标（会因此修改数组的内容而不是添加一个属性）
```javascript
var myArray = ["foo",42,"bar"];
myArray["3"] = "baz";
console.log(myArray.length);
myArray[10] ="10";
console.log(myArray.length);
```
###### 复制对象

```javascript
function anotherFunction() {}
var anotherObject = {
  c:true
};
var anotherArrary = [];
var myObject = {
  a : 2,
  b : anotherObject,
  c : anotherArrary,
  d : anotherFunction
};
anotherArrary.push(anotherObject,myObject);
```
就复制来说，浅复制复制出的新对象中a的值会复制就对象中a旳值，但是新对象中bcd三个属性其实是三个引用，与旧对象中bcd的引用的对象是一样的.但是就深复制来说复制的对象之间可能会相互嵌套，引发循环引用导致循环坏死

相比深复制，浅复制非常易懂而且问题要少得多：Object.assign(..)方法的第一个参数是目标对象，之后还可以跟一个或多个源对象，它会遍历一个或多个源对象的所有可枚举的自有键并把它们复制到目标对象（使用=操作符赋值），最后返回目标对象
```javascript
var newObj = Object.assign({},myObject);
newObj.a;//2;
newObj.b === anotherObject;//true
newObj.c === anotherArrary;//true
newObj.d === anotherFunction;//true
```

---
###### 属性描述符
```javascript
var myObject = {
  a:2
};
console.log(Object.getOwnPropertyDescriptor(myObject,"a")); // { value: 2, writable: true, enumerable: true, configurable: true }
```
这个普通的对象属性对应的属性描述符（“也被称为数据描述符”）还包括另外三个特性:writable(可写)，enumerable(可枚举)，configurable(可配置)

创建普通属性的时候属性描述符会使用默认值，但是也可以使用Object.defineProperty(..)来添加或修改一个已有属性（configurable为true）并对特性进行设置
```javascript
var myObject = {};
Object.defineProperty(myObject,"a",{
  value:2,
  writable:true,
  configurable:true,
  enumerable:true
});
console.log(myObject.a); //2

```
1. Writable

决定是否修改属性的值
```javascript
var myObject = {};
Object.defineProperty(myObject,"a",{
  value:2,
  writable:false,
  configurable:true,
  enumerable:true
});
console.log(myObject.a);
myObject.a = 3; //静默失败，严格模式下报TypeError
console.log(myObject.a);

```

2. Configurable

只要属性是可配置的，就可以使用defineProperty(..)方法来修改属性描述符
```javascript
var myObject = {
  a:2
};
myObject.a = 3
console.log(myObject.a);//3

Object.defineProperty(myObject,"a",{
  value:4,
  writable:true,
  configurable:false,
  enumerable:true
});
console.log(myObject.a);//4
myObject.a = 5;
console.log(myObject.a);//5
Object.defineProperty(myObject,"a",{
  value:6,
  writable:true,
  configurable:true,
  enumerable:true
});//不管是不是严格模式都会报错typeError
```
**把configurable修改成false是单向操作，无法撤销**

configurable:false还会禁止删除这个属性
```javascript
var myObject = {
  a:2
};
console.log(myObject.a);//2
delete myObject.a;
console.log(myObject.a);//undefined

Object.defineProperty(myObject,"a",{
  value:4,
  writable:true,
  configurable:false,
  enumerable:true
});
console.log(myObject.a);//4
delete myObject.a;//静默失败
console.log(myObject.a);//4

```

3. Enumerable

可枚举性，比如说在for..in循环，如果把enumerable设置成false，这个属性就不会出现在枚举中，但是仍然可以正常的访问它

---
###### 不变性

1. 对象常量

结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改，重定义，删除）
```javascript
var myObject = {};
Object.defineProperty(myObject,"FAVORITE_NUMBER",{
  value:4,
  writable:false,
  configurable:false,
});
```
2. 禁止拓展

想禁止一个对象添加新属性并保留已有属性，可以使用Object.preventExtension(..)
```javascript
var myObject = {
  a:2
};
console.log(myObject.a)
Object.preventExtensions(myObject);

myObject.b = 5;
console.log(myObject.b)
```
非严格模式下，创建b会静默失败，严格模式下会抛出TypeError错误
3. 密封

Object.seal(..)会创建一个“密封”的对象，实际上就是在现有对象上调用Object.preventExtension(..)并把所有的属性标记为configurable:false，所以密封后不仅不能添加新属性，也不能重新配置或删除现有属性（但可以修改属性的值）

4. 冻结Object.freeze(..)会创建一个冻结对象，这个方法实际上就是在一个现有的对象上调用Object.seal(..)并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值
 
> "深度冻结"对象：首先对这个对象调用Object.freeze(..)，然后遍历它的所有属性，并对这些对象调用Object.freeze(..)**但是要小心，这样做可能会冻结其它（共享）对象**

---
###### [[Get]]
```javascript
var myObject = {
    a:2
};
myObject.a;//2
```
myObject.a是一次属性访问，myObject.a在myObject上实际上是实现了[[Get]]操作（有点像函数调用[[Get]]()）。对象默认的的内置[[Get]]操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值。如果没有找到，按照[[Get]]算法定义会遍历可能存在的原型链。如果无论如何都没有找到名称相同的属性，那么[[Get]]会返回**undefined**

> 访问不存在的变量时则会返回ReferenceError；

###### [[Put]]
有获取属性的[[Get]]操作，就一定有与之对应的[[Put]]。
[[Put]]被触发时，实际的行为取决于许多因素，包括对象中是否已经存在这个属性，如果已经存在这个属性，[[Put]]算法大致会检查：
1. 属性是否存在访问描述符？如果是并且存在setter就调用setter
2. 属性的数据描述符中writable是否是false？如果是，非严格模式下静默失败，严格模式下抛出异常TypeError异常。
3. 如果都不是，将该值设置为属性的值。

如果对象中不存在这个属性[[Put]]操作会更加复杂。。。

###### Getter和Setter
在ES5中可以使用getter和setter部分改写默认操作，但是只能对应在单个属性上，无法应用在整个对象上，getter是一个隐藏函数，会在获取属性值时调用，setter也是一个隐藏函数，会在设置属性值时调用。

当你给一个属性定义getter，setter或者两者都有的时候，这个属性会被定义为“访问描述符”对访问描述符来说，JavaScript会忽略它们的value和writable特性,取而代之的是关心set和get（还有configurable和enumerable）特性
```javascript
var myObject = {
  // 给a定义一个getter
  get a(){
    return 2;
  }
};
Object.defineProperty(
  myObject,
  "b",
  {//描述符
    //给b设置一个getter
    get:function(){return this.a*2},
    //确保不会出现在对象的属性列表
    enumerable:true
  }
);
console.log(myObject.a);
console.log(myObject.b);
```
不管是对象文字语法中的get a() {..},还是defineProperty（..）中的显示定义，二这都会在对象中创建一个不包含值得属性，对于这个属性的访问会自动调用一个隐式函数，它的返回值会被当做属性访问的返回值：
```javascript
var myObject = {
  // 给a定义一个getter
  get a(){
    return 2;
  }
};
myObject.a = 3;
console.log(myObject.a);//2
```
由于只定义了a的getter，所以对a旳值进行设置时set操作会忽略赋值操作，不会抛出错误。而且即使有合法的setter，由于我们自定义的getter只会返回2，所以set操作是没有意义的

为了让属性更合理，还应当定义setter，setter会覆盖单个属性默认的[[put]]操作，通常来说getter和setter是成对出现：

```javascript
var myObject = {
  // 给a定义一个getter
  get a(){
    return this._a_;
  },
  set a(val){
    this._a_ = val * 2;
  }
};
myObject.a = 4;
console.log(myObject.a);//8
```
###### 存在性
```javascript
var myObject = {
  a:undefined
};
console.log(myObject.a);//undefined
console.log(myObject.b);//undefined
```
myObject.a的返回值是undefined，这个undefined可能是属性中储存的值，也可能是因为属性不存在所以返回undefined，如何区分？

不访问属性值的情况下判断是否存在这个属性：
```javascript
var myObject = {
  a:undefined
};
console.log(myObject.a);//undefined
console.log(myObject.b);//undefined

console.log("a" in myObject);//true
console.log("b" in myObject);//false

console.log(myObject.hasOwnProperty("a")); //true
console.log(myObject.hasOwnProperty("b")); //false
```
in操作符会检查属性是否在对象及其[[Prototype]]原型链中,hasOwnProperty(..)只会1检查属性是否在myObject对象中

所有的普通对象都可以通过对于Object.prototype委托来访问hasOwnProperty(..),但是有的对象可能没有连接到Object.prototype（通过Object.create(null)来创建），这种情况下形如myObject.hasOwnProperty(..)就会失败。

这是可以使用一种更加强硬的方法来判断：Object.prototype.hasOwnProperty.call(myObject,"a"),它借用基础的hasOwnProperty(..)方法，并把它显示绑定

> in 操作符检查的是某个**属性名**是否存在，而不是值：4 in [2,4,6]的结果是false

**枚举**
```javascript
var myObject = {};

Object.defineProperty(
  myObject,
  "a",
  {enumerable:true,value:2}
);
Object.defineProperty(
  myObject,
  "b",
  {enumerable:false,value:4}
);
console.log(myObject.b); // 4
console.log("b" in myObject); //true
console.log(myObject.hasOwnProperty("b")); //true

for (var k in myObject) {
  console.log(k,myObject[k]);
}
//a 2
```
> 数组上应用for..in循环有时会产生出人意料的结果，最好只在对象中应用for..in循环，遍历数组用传统的for循环就好

其他方法区分属性是否可枚举
```javascript
var myObject = {};

Object.defineProperty(
  myObject,
  "a",
  {enumerable:true,value:2}
);
Object.defineProperty(
  myObject,
  "b",
  {enumerable:false,value:4}
);
console.log(myObject.propertyIsEnumerable("a"));//true
console.log(myObject.propertyIsEnumerable("b"));//false

console.log(Object.keys(myObject));//[ 'a' ]
console.log(Object.getOwnPropertyNames(myObject)); //[ 'a', 'b' ]
```
propertyIsEnumerable(..)检查属性是否直接存在对象中（而不是原型链上），并且满足enumerable：true

Object.keys(..)返回一个数组包含所有可枚举属性

Object.getOwnPropertyNames(..)返回一个数组包含所有属性，无论是否可枚举

---
###### 遍历

for..in循环可以用来遍历对象的可枚举属性列表。

对于数组来说，可以使用标准的for循环来遍历值
```javascript
var myArray = [1, 2, 3];
for(var i = 0; i < myArray.length; i++) {
  console.log(myArray[i]);
}
```
这实际上不是遍历值，而是遍历下标来指向值

ES5中增加了一些数组的辅助迭代器，包括forEach(..),every(..)和some(..)。每种辅助迭代器都可以接受一个回调函数并把它应用到数组的每个元素上，唯一的区别就是他们对于回调函数返回值的处理方式不同。

forEach(..)会遍历数组中的所有值并忽略回调函数的返回值。

every(..)会一直运行直到回调函数返回false。

some(..)会一直运行直到回调函数返回true。

ES6中增加的一种用来遍历数组的for..of循环（如果本身定义了迭代器的话也可以遍历对象）
```javascript
var myArray = [1, 2, 3];
for (var v of myArray) {
  console.log(v);
}
//1
//2
//3
```
for..of循环首先会向被访问对象请求一个迭代对象，然后通过调用迭代对象的next()方法来遍历所有的返回值
