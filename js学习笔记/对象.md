# 对象

### 语法

对象可以通过两种方法定义：声明（文字）形式和构造形式

声明：
```
var myObj = {
    key:value
    //...
};
```
构造：
```
var myObj = new Object();
myObj.key = value;
```
构造形式和文字形式生成的对象是一样的，唯一的区别是文字形式你可以一次添加多个键值对，而构造形式中必须逐个添加属性

---

### 类型

对象是JavaScript的基础，在JavaScript中一共有六种主要类型（术语是“语言类型”）：

- string
- number
- boolean
- null
- undefined
- object

> 注意：简单基本类型（string,number,boolean,null,undefined）本身并不是对象。null有时会被当做一种对象类型，但是这其实只是语言本身的BUG，即对null执行typyof null时会返回字符串“object”。实际上null本身是基本类型。

有一种常见的错误说法“JavaScript中万物皆对象”，这显然是错误的。

实际上，JavaScript中有许多特殊的对象子类型，我们可以称之为复杂基本类型

函数就是对象的一个子类型，数组也是对象的一种类型

#### 内置对象

JavaScript中还有一些对象子类型，通常被称为内置对象。有些内置对象的名字看起来和简单基本类型一样，不过实际上他们关系更复杂

- String
- Number
- Boolean
- Object
- Function
- Array
- Date
- RegExp
- Error
 
这些内置对象从表现形式上来说很像其他语言中的类型（type）或者类（class）比如Java中的String类。
但是在JavaScript中，它们实际上只是一些内置函数，这些内置函数可以当做构造函数（由new产生的函数调用）来使用，从而可以构造一个对应子类型的新对象
```
var strPrimitive = "I am a string";
console.log(typeof strPrimitive);//string
console.log(strPrimitive instanceof String);//false

var strObject = new String("I am a string");
console.log(typeof strObject);//object
console.log(strObject instanceof String);//true

//检查 sub-type 对象
console.log(Object.prototype.toString.call(strObject));//[object String]

```

strObject是由String构造函数创建一个对象，原始值“I am a string”并不是一个对象，它只是一个字面量，并且是一个不可变得值。如果要在这个字面量上执行一些操作，比如获取长度，访问其中某一个字符等，那就需要将其转换为String对象。有必要时语言会自动把字符串字面量转换成一个String对象

```
var strPrimitive = "I am a string";
console.log(strPrimitive.length); // 13
console.log(strPrimitive.charAt(3)); //m
```
使用以上两种方法可以直接在字符串字面量上访问属性和方法，因为引擎自动把字面量转换成String对象，所以可以访问属性和方法
同样的事也会发生在数值字面量上，如果使用42.123toFixed(2)的方法，引擎会把42转换成new number(42).对于布尔字面量来说也是如此

> null和undefined没有对应的构造形式，它们只有文字形式，相反，Date只有构造，没有文字形式。

> 对于Object，Array，Function，和RegExp（正则表达式）来说，无论使用文字形式还是构造形式，它们都是对象，不是字面量

> Error对象很少在代码中显式创建，一般是在抛出异常时被自动创建

#### 内容

```
var myObject = {
  a:2
};
console.log(myObject.a);//2
console.log(myObject["a"]);//2
```
.a语法通常被称为“属性访问”；

["a"]语法通常被称为“建访问”；

实际上它们访问的是同一个位置，所以这两个术语是可以相互转换的

这两种愈发的主要区别就是：.操作符要求属性名满足标识符的命名规范，而[".."]语法可以接受任意UFT-8/Unicode字符串作为属性名。比如要引用“Super-Fun!”就只能使用["Super-Fun"]

> 属性名永远是字符串，即使使用string（字面量）以外的其它属性名，那么他首先会被转换成字符串

###### 可计算属姓名

ES6增加了可计算属性名，可以在文字形式中使用[]包裹一个表达式来当属性名：
```
var prefix = "kidder";

var myObject = {
  [prefix+"cool"]:"hello!",
  [prefix+"bar"]:"kidder"
};

console.log(myObject.kiddercool);//hello!
console.log(myObject.kidderbar);//kidder
```
######  数组

数组也支持[]访问形式，数组期望的是数值下标，也就是说值存储的位置（通常被称为索引）是非负整数
```
var myArray = ["foo",42,"bar"];
myArray.length; //3
myArray[0]; //"foo"
myArray[2]; //"bar" 
```
数组也是对象，所以虽然每个下标都是整数，你仍然可以给数组添加属性
```
var myArray = ["foo",42,"bar"];
myArray.baz = "baz";
myArray.length; //3
console.log(myArray.baz);
```
> 虽然添加了命名属性，但数组的length值并没有发生变化

注意:如果你试图向数组添加一个属性，但属性名“看起来”像个数字，那么它就会变成一个数值的下标（会因此修改数组的内容而不是添加一个属性）
```
var myArray = ["foo",42,"bar"];
myArray["3"] = "baz";
console.log(myArray.length);
myArray[10] ="10";
console.log(myArray.length);
```
###### 复制对象

```
function anotherFunction() {}
var anotherObject = {
  c:true
};
var anotherArrary = [];
var myObject = {
  a : 2,
  b : anotherObject,
  c : anotherArrary,
  d : anotherFunction
};
anotherArrary.push(anotherObject,myObject);
```

---
###### 属性描述符
```
var myObject = {
  a:2
};
console.log(Object.getOwnPropertyDescriptor(myObject,"a")); // { value: 2, writable: true, enumerable: true, configurable: true }
```
这个普通的对象属性对应的属性描述符（“也被称为数据描述符”）还包括另外三个特性:writable(可写)，enumerable(可枚举)，configurable(可配置)

创建普通属性的时候属性描述符会使用默认值，但是也可以使用Object.defineProperty(..)来添加或修改一个已有属性（configurable为true）并对特性进行设置
```
var myObject = {};
Object.defineProperty(myObject,"a",{
  value:2,
  writable:true,
  configurable:true,
  enumerable:true
});
console.log(myObject.a); //2

```
1. Writable

决定是否修改属性的值
```
var myObject = {};
Object.defineProperty(myObject,"a",{
  value:2,
  writable:false,
  configurable:true,
  enumerable:true
});
console.log(myObject.a);
myObject.a = 3; //静默失败，严格模式下报TypeError
console.log(myObject.a);

```

2. Configurable

只要属性是可配置的，就可以使用defineProperty(..)方法来修改属性描述符
```
var myObject = {
  a:2
};
myObject.a = 3
console.log(myObject.a);//3

Object.defineProperty(myObject,"a",{
  value:4,
  writable:true,
  configurable:false,
  enumerable:true
});
console.log(myObject.a);//4
myObject.a = 5;
console.log(myObject.a);//5
Object.defineProperty(myObject,"a",{
  value:6,
  writable:true,
  configurable:true,
  enumerable:true
});//不管是不是严格模式都会报错typeError
```
**把configurable修改成false是单向操作，无法撤销**

configurable:false还会禁止删除这个属性
```
var myObject = {
  a:2
};
console.log(myObject.a);//2
delete myObject.a;
console.log(myObject.a);//undefined

Object.defineProperty(myObject,"a",{
  value:4,
  writable:true,
  configurable:false,
  enumerable:true
});
console.log(myObject.a);//4
delete myObject.a;//静默失败
console.log(myObject.a);//4

```

3. Enumerable

可枚举性，比如说在for..in循环，如果把enumerable设置成false，这个属性就不会出现在枚举中，但是仍然可以正常的访问它

---
###### 不变性

1. 对象常量

结合writable:false和configurable:false就可以创建一个真正的常量属性（不可修改，重定义，删除）
```
var myObject = {};
Object.defineProperty(myObject,"FAVORITE_NUMBER",{
  value:4,
  writable:false,
  configurable:false,
});
```
2. 禁止拓展

想禁止一个对象添加新属性并保留已有属性，可以使用Object.preventExtension(..)
```
var myObject = {
  a:2
};
console.log(myObject.a)
Object.preventExtensions(myObject);

myObject.b = 5;
console.log(myObject.b)
```
非严格模式下，创建b会静默失败，严格模式下会抛出TypeError错误
3. 密封

Object.seal(..)会创建一个“密封”的对象，实际上就是在现有对象上调用Object.preventExtension(..)并把所有的属性标记为configurable:false，所以密封后不仅不能添加新属性，也不能重新配置或删除现有属性（但可以修改属性的值）

4. 冻结Object.freeze(..)会创建一个冻结对象，这个方法实际上就是在一个现有的对象上调用Object.seal(..)并把所有“数据访问”属性标记为 writable:false，这样就无法修改它们的值
 
> "深度冻结"对象：首先对这个对象调用Object.freeze(..)，然后遍历它的所有属性，并对这些对象调用Object.freeze(..)**但是要小心，这样做可能会冻结其它（共享）对象**
