# 作用域闭包

当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使**函数是在当前词法作用域之外执行**

```
function foo() {
    var a = 2;
    function bar () {
        console.log(a);
    }
    return bar;
}

var baz = foo();
baz();
```
foo()执行后，其返回值（就是bar()函数）被赋值给变量baz并调用baz（）

在foo（）被执行后，通常会期待foo（）的整个内部作用域会被销毁，因为我们知道JavaScript引擎有垃圾回收机制来释放不在使用的内存空间，由于foo()的内容看上去不会在被使用，所以很自然地会考虑对其回收

而闭包的神奇之处就是阻止这件事情的发生，事实上内部作用域依然存在，因此没有被回收，是bar本身在使用

bar依然持有对该作用域的引用，这个引用就叫闭包

无论以何种手段将内部函数传递到所在词法作用域之外，他都会持有对原始定义作用域的引用

### 循环和闭包


```
for (var i=1;i<=5;i++) {
    setTimeout(function Timer() {
        console.log(i)
    },i*1000);
}
```
预期：分别输出1-5，每秒一次，每次一个
实际：每秒一次，输出5次6，
> 即使每个迭代中执行的是setTimeout(..,0),所有的回调函数依然是循环结束后才被执行

```
for (var i=1;i<=5;i++) {
    (function() {
        setTimeout(function Timer() {
        console.log(i)
    },i*1000);
    })();
}
```
每个延迟函数都会将IIFE在每次迭代中创建的作用域封闭起来，但是如果作用域是空的，仅仅将他们封闭是不够的，它需要自己的变量

```
for (var i=1;i<=5;i++) {
    (function() {
        var j = i;
        setTimeout(function Timer() {
        console.log(j)
    },j*1000);
    })();
}
```
这样就可以了，改进：
```
for (var i=1;i<=5;i++) {
    (function(j) {
        setTimeout(function Timer() {
        console.log(j)
    },j*1000);
    })(i);
}
```
如果用块作用域的话
```
for (var i=1;i<=5;i++) {
    let j = i;
    setTimeout(function Timer() {
        console.log(j)
    },j*1000);
}
```
进一步

```
for (let i=1;i<=5;i++) {
  setTimeout(function Timer() {
      console.log(i)
  },i*1000);
}
```
---
### 模块

考虑以下代码
```
function CoolModule() {
    var something = "cool";
    var another = [1,2,3];
    function doSomething() {
        console.log(something);
    }
    function doAnother() {
        console.log(another.join("!"));
    }
    return {
        doSomething:doSomething,
        doAnother:doAnother
    };
}
var foo = CoolModule();
foo.doSomething();
foo.doAnother();
```

这个模式在JavaScript中被称为模块，最常见的实现模块的方法通常被称为“模块暴露”，这个是其变体
首先，CoolModule（）只是一个函数，必须通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建

其次，CoolModule（）返回一个用对象字面量语法{key:value,..}来表示的对象。这个返回的对象中含有对内部函数而不是对内部数据变量的引用。我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共API

最终，这个对象类型的返回值最终被赋值给外部的变量foo,然后就可以通过它来访问API中的属性和方法

**模块模式需要具备两个必要条件：**
1. 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
2. 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态

上个示例代码中有一个独立的模块创建器CoolModule() ，可以被任意次调用，每次调用都会创建一个新的模块实例。当只需要一个实例时，可以对模块进行简单的修改实现单例模式：
```
var foo = (function CoolModule() {
    var something = "cool";
    var another = [1,2,3];
    function doSomething() {
        console.log(something);
    }
    function doAnother() {
        console.log(another.join("!"));
    }
    return {
        doSomething:doSomething,
        doAnother:doAnother
    };
})();
foo.doSomething();
foo.doAnother();
```

模块也是普通的函数，因此可以接受参数
```
function CoolModule(id) {
    function identify() {
        console.log(id);
    }
    return {
        identify:identify
    };
}
var foo1 = CoolModule("foo1");
var foo2 = CoolModule("foo2");
foo1.identify();// "foo1"
foo2.identify();// "foo2"
```
模块模式另一个简单但强大的法是命名将要作为公共API返回的对象：
```
var foo = (function CoolModule(id) {
  function change() {
      publicAPI.identify = identify2;
  }
  function identify1() {
      console.log(id);
  }
  function identify2() {
      console.log(id.toUpperCase());
  }
  var publicAPI = {
      change:change,
      identify:identify1
  };
  return publicAPI
})("foo mudule");
foo.identify(); // foo mudule
foo.change();
foo.identify(); // FOO MUDULE
```

---
现代的模块机制

大多数模块依赖加载器/管理器本质上都是将这种模块定义封装进一个友好的API
```
var MyModules = (function Manager() {
  var modules = {};
  function define(name,deps,impl) {
    for(var i=0;i<deps.length;i++) {
      deps[i] = modules[deps[i]];
    }
    modules[name] = impl.apply(impl,deps);
  }
  function get(name) {
    return modules[name];
  }
  return {
    define:define,
    get:get
  };
})();
```
这段代码的核心是 modules[name] = impl.apply(impl,deps)。为了模块的定义引入了包装函数（可以传入任何依赖），并将返回值，也就是模块的API，存储在一个根据名字来管理的模块列表中。

下面展示如何使用它来定义模块：
```
MyModules.define("bar",[],function() {
  function hello(who) {
    return "Let me introduce:"+ who;
  }
  return {
    hello:hello
  };
});
MyModules.define("foo",["bar"],function(bar) {
  var hungry = "hippo";
  function awesome() {
    console.log(bar.hello(hungry).toUpperCase());
  }
  return {
    awesome:awesome
  };
});
var bar = MyModules.get("bar");
var foo = MyModules.get("foo");

console.log(bar.hello("hippo")); //Let me introduce:hippo

foo.awesome();//LET ME INTRODUCE:HIPPO
```
“foo”和“bar”模块都是通过返回一个公共API的函数来定义的，“foo”甚至接受“bar”的实例作为依赖参数，并能相应的使用它

它们符合模块模式的两个特点：调用包装了函数定义的包装函数，并且将返回值作为该模块的API

---
未来的模块机制

ES6中为模块增加了一级语法支持。再通过模块系统进行加载时，ES6会将文件当做独立的模块来处理。每个模块都可以导入其它模块或特定的API成员，同样也可以导出自己的API成员。

ES6的模块没有“行内”格式，必须被定义在独立的文件中（一个文件一个模块）
```
//bar.js
function hello(who) {
    return "Let me introduce:"+who;
}
export hello
```
```
//foo.js
//仅从“bar”模块导入hello()
import hello from "bar";

var hungry = "hippo";

function awesome() {
    console.log(
        hello(hungry).toUpperCase()
    );
}

export awesome;
```
```
// baz.js
//导入完整的“foo”和“bar”模块
module foo from "foo";
module bar from "bar";

console.log(bar.hello("rhino"));//Let me introduce: rhino

foo.awesome();// LET ME INTRODUCE:HIPPO
```
> import 可以将一个模块中的一个或多个API导入当前作用域中，并分别绑定在一个变量上(hello)

> module会将整个模块的API导入并绑定到一个变量上（foo和bar）

> export会将当前模块的一个标识符（变量、函数）导出为公共的API

模块文件中的内容会被当做好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样